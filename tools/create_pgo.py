#!/usr/bin/env python3
"""
Profile-Guided Optimization (PGO) Profile Generator
===================================================

This script automates the creation of CPU profiles for Go's Profile-Guided Optimization (PGO).
PGO allows the Go compiler to optimize the application based on runtime behavior, potentially
improving performance by 2-14% (depending on the workload).

The script performs the following steps:
1.  **Cleanup**: Removes any existing profile files to ensure a clean state.
2.  **Benchmark**: Runs Go benchmarks for specified critical packages.
    -   It uses `-cpuprofile` to capture execution data.
    -   It disables existing PGO (`-pgo=off`) to establish a baseline.
    -   It runs for 10 seconds (`-benchtime=10s`) to gather sufficient samples.
3.  **Merge**: Combines individual package profiles into a single `cpuprofile.pprof` file.
    -   The Go compiler expects a single profile file for PGO.
4.  **Visualize**: Generates an SVG graph (`cpuprofile.svg`) for human analysis.
5.  **Cleanup**: Removes intermediate files, leaving only the final artifacts.

Usage:
    python3 tools/create_pgo.py

Expected working directory:
    Run this from the repository root. The script writes artifacts into the
    current working directory.

Prerequisites:
    - Go toolchain on PATH (this script runs `go test` and `go tool pprof`).
    - Graphviz installed if you want the SVG output (`go tool pprof -svg` calls `dot`).

Side effects:
    - Deletes matching files in the working directory:
      - cpuprofile*.pprof
      - *.test
    - Overwrites `cpuprofile.pprof` and `cpuprofile.svg`.

Artifacts:
    - cpuprofile.pprof: The merged profile used by `go build -pgo`.
    - cpuprofile.svg:   A visualization of the profile for performance analysis.

Template note:
    Profiling artifacts are typically generated locally and ignored by git in this
    template. If you want stable, reproducible image builds across machines, you can
    commit `cpuprofile.pprof` and remove the ignore rule for it.
"""

import glob
import os
import re
import subprocess
import sys

# List of packages to profile.
# These should be the core domains and adapters where performance matters most.
PACKAGES_TO_PROFILE = [
    "cmd/server",
    "internal/adapters/inbound",
    "internal/adapters/outbound",
]

# Regex pattern for valid Go package paths (alphanumeric, underscores, hyphens, slashes)
# This prevents any shell metacharacters or path traversal attempts.
VALID_PACKAGE_PATTERN = re.compile(r"^[a-zA-Z0-9_\-/]+$")


def validate_package_path(pkg: str) -> bool:
    """
    Validates that a package path is safe for use in subprocess commands.

    Args:
        pkg: The package path to validate.

    Returns:
        True if the package path is valid, False otherwise.

    Security:
        This prevents command injection by ensuring package paths only contain
        safe characters (alphanumeric, underscores, hyphens, forward slashes).
        It also rejects path traversal attempts (../).
    """
    if not pkg:
        return False
    if ".." in pkg:  # Reject path traversal
        return False
    if not VALID_PACKAGE_PATTERN.match(pkg):
        return False
    return True


def run_command(command, check=True, stdout=None):
    """
    Runs a command and handles errors gracefully.

    Args:
        command (list): The command and arguments as a list.
        check (bool): Whether to raise an exception on non-zero exit codes.
        stdout: Optional file handle for stdout redirection.
    """
    try:
        subprocess.run(command, check=check, stdout=stdout)
    except subprocess.CalledProcessError as e:
        print(f"Error running command: {command}")
        sys.exit(e.returncode)


def main():
    print("Starting PGO profile generation...")

    # -------------------------------------------------------------------------
    # 0. Validate package paths (defense-in-depth)
    # -------------------------------------------------------------------------
    for pkg in PACKAGES_TO_PROFILE:
        if not validate_package_path(pkg):
            print(f"Error: Invalid package path '{pkg}'. Aborting for security.")
            sys.exit(1)

    # -------------------------------------------------------------------------
    # 1. Cleanup existing profiles
    # -------------------------------------------------------------------------
    print("Cleaning up old profiles...")
    # These files are generated artifacts. We remove them first to avoid
    # accidentally merging stale data.
    # Remove any previous pprof files to avoid merging old data
    for f in glob.glob("cpuprofile*.pprof"):
        os.remove(f)
    # Remove test binaries generated by 'go test'
    for f in glob.glob("*.test"):
        os.remove(f)

    # -------------------------------------------------------------------------
    # 2. Run benchmarks for each package
    # -------------------------------------------------------------------------
    # The profile quality depends on representative workloads.
    # We use benchmarks as the workload driver because they are deterministic and
    # live close to the code under test.
    for pkg in PACKAGES_TO_PROFILE:
        print(f"Profiling package: {pkg}")

        # Create a safe filename suffix (replace / with __) to avoid path issues
        suffix = pkg.replace("/", "__").replace("\\", "__")
        output_file = f"cpuprofile-{suffix}.pprof"

        # Construct the go test command for benchmarking
        # -run=^$      : Don't run any unit tests (only benchmarks)
        # -bench=.     : Run all benchmarks in the package
        # -benchtime=10s : Run for 10 seconds to ensure statistically significant data
        # -cpuprofile  : Output the CPU profile to a specific file
        # -pgo=off     : IMPORTANT: Disable PGO during profiling to get a clean baseline.
        #                Profiling an already optimized binary can skew results.
        cmd = [
            "go",
            "test",
            f"./{pkg}/...",
            "-run=^$",
            "-bench=.",
            "-benchtime=10s",
            f"-cpuprofile={output_file}",
            "-pgo=off",
        ]

        # Run the benchmark, suppressing stdout/stderr to keep the output clean.
        # We only care if it fails.
        try:
            subprocess.run(
                cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )
        except subprocess.CalledProcessError:
            print(f"Failed to profile package: {pkg}")
            sys.exit(1)

    # -------------------------------------------------------------------------
    # 3. Merge profiles
    # -------------------------------------------------------------------------
    print("Merging profiles...")
    # The Go compiler needs a single profile file. We use 'go tool pprof' to merge
    # the individual package profiles into one.
    # We use Python's glob to expand the pattern safely (avoiding shell=True).
    profile_files = glob.glob("cpuprofile-*.pprof")
    if not profile_files:
        print("Error: No profile files found to merge.")
        sys.exit(1)
    merge_cmd = ["go", "tool", "pprof", "-proto"] + profile_files
    with open("cpuprofile-merged.pprof", "wb") as outfile:
        run_command(merge_cmd, stdout=outfile)

    # -------------------------------------------------------------------------
    # 4. Finalize profile file
    # -------------------------------------------------------------------------
    print("Finalizing cpuprofile.pprof...")
    # Rename/Copy the merged file to the standard name 'cpuprofile.pprof'
    # This is the file that should be committed to the repo for PGO.
    try:
        with (
            open("cpuprofile-merged.pprof", "rb") as src,
            open("cpuprofile.pprof", "wb") as dst,
        ):
            dst.write(src.read())
    except IOError as e:
        print(f"Error copying merged profile: {e}")
        sys.exit(1)

    # -------------------------------------------------------------------------
    # 5. Generate visualization
    # -------------------------------------------------------------------------
    print("Generating SVG visualization...")
    # Create an SVG graph of the profile. This is useful for developers to see
    # where the application is spending its time (hot paths).
    svg_cmd = ["go", "tool", "pprof", "-svg", "cpuprofile.pprof"]
    with open("cpuprofile.svg", "wb") as outfile:
        run_command(svg_cmd, stdout=outfile)

    # -------------------------------------------------------------------------
    # 6. Cleanup intermediate files
    # -------------------------------------------------------------------------
    print("Cleaning up intermediate files...")
    # Remove the individual package profiles and the temporary merged file
    for f in glob.glob("cpuprofile-*.pprof"):
        os.remove(f)
    for f in glob.glob("*.test"):
        os.remove(f)

    if os.path.exists("cpuprofile-merged.pprof"):
        os.remove("cpuprofile-merged.pprof")

    print("PGO generation complete!")
    print("  - Created 'cpuprofile.pprof' (Commit this file)")
    print("  - Created 'cpuprofile.svg'   (View this to analyze performance)")


if __name__ == "__main__":
    main()
